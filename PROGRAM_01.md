# _PROGRAM_01: AI_ENGINEERING_BOOTCAMP_

Kompletny, 12-modu≈Çowy bootcamp ≈ÇƒÖczƒÖcy zaawansowany Python, LLM Engineering oraz budowƒô autonomicznych system√≥w agentowych. Od fundament√≥w do produkcyjnych rozwiƒÖza≈Ñ AI.

---

## üöÄ FAZA 1: FUNDAMENTY (Python & AI Basics)

### **Modu≈Ç 1: Wprowadzenie do Modern AI Engineering**

Ikona do wstawienia dla potwierdzenia statusu: ‚úÖ

| Lekcja | Temat G≈Ç√≥wny                                                      | Tech Stack                      | Status |
| ------ | ----------------------------------------------------------------- | ------------------------------- | ------ |
| **01** | Kim jest AI Engineer w 2025? (Rola Solo Operatora w ekosystemie)  | `koncepcje`                     |        |
| **02** | Dlaczego Lean AI? Wady framework√≥w "heavy-abstraction"            | `architektura`                  |        |
| **03** | PrzeglƒÖd stacku: PydanticAI, Google SDK, Langfuse, Qdrant         | `pydantic-ai, gemini, langfuse` |        |
| **04** | Modele lokalne (Ollama, DeepSeek) vs Chmura w pe≈Çni kontrolowana  | `ollama, deepseek`              |        |
| **05** | Cykl ≈ºycia aplikacji AI: Od notebooka do mikroserwisu             | `jupyter, fastapi`              |        |
| **06** | Strategia "Code-First": Budowanie system√≥w, kt√≥re przetrwajƒÖ lata | `best-practices`                |        |

**Oczekiwane Wyniki:**

- Zdefiniujesz swojƒÖ ≈õcie≈ºkƒô jako Modern AI Engineer i zrozumiesz rolƒô w organizacji
- Zrozumiesz dlaczego podej≈õcie 'lean' wygrywa z ciƒô≈ºkimi frameworkami
- Skonfigurujesz sw√≥j pierwszy profesjonalny stack technologiczny do pracy z modelami

---

### **Modu≈Ç 2: Zaawansowany Python dla AI**

| Lekcja | Temat G≈Ç√≥wny                                              | Tech Stack              | Status |
| ------ | --------------------------------------------------------- | ----------------------- | ------ |
| **01** | Typowanie statyczne: Type Hints i Mypy w us≈Çugach AI      | `typing, mypy`          |        |
| **02** | Zaawansowane typowanie: Generics i TypedDict w AI         | `typing`                |        |
| **03** | Programowanie asynchroniczne (asyncio) ‚Äì wprowadzenie     | `asyncio`               |        |
| **04** | Fundamenty szybkich agent√≥w: Event Loop i Taski           | `asyncio`               |        |
| **05** | Programowanie obiektowe (OOP) w in≈ºynierii AI             | `python-oop`            |        |
| **06** | Podej≈õcie funkcyjne vs obiektowe: Kiedy co stosowaƒá?      | `functional-python`     |        |
| **07** | Modu≈Çowo≈õƒá: Projektowanie "pluggable" system√≥w agentowych | `design-patterns`       |        |
| **08** | ZarzƒÖdzanie zale≈ºno≈õciami i architektura czystego kodu    | `clean-architecture`    |        |
| **09** | Obs≈Çuga b≈Çƒôd√≥w i Custom Exceptions w przep≈Çywach LLM      | `exception-handling`    |        |
| **10** | Strategie retries i odporno≈õƒá system√≥w AI                 | `tenacity, backoff`     |        |
| **11** | Optymalizacja wydajno≈õci kodu Pythona dla obciƒÖ≈ºe≈Ñ AI     | `profiling, cProfile`   |        |
| **12** | Praca z du≈ºymi zbiorami danych i leniwe ≈Çadowanie         | `generators, itertools` |        |

**Oczekiwane Wyniki:**

- Napiszesz w pe≈Çni typowany i bezpieczny kod Python dla system√≥w agentowych
- Opanujesz asynchroniczno≈õƒá (asyncio) niezbƒôdnƒÖ do szybkich interakcji z LLM
- Zbudujesz fundament pod modu≈Çowe komponenty AI, kt√≥re ≈Çatwo skalowaƒá

---

## üß† FAZA 2: LLM CORE & DATA FOUNDATIONS

### **Modu≈Ç 3: Pydantic ‚Äì Fundament Struktury Danych**

| Lekcja | Temat G≈Ç√≥wny                                                   | Tech Stack            | Status |
| ------ | -------------------------------------------------------------- | --------------------- | ------ |
| **01** | Pydantic jako "Single Source of Truth" w systemach AI          | `pydantic`            |        |
| **02** | Definiowanie schemat√≥w wyj≈õciowych (Structured Outputs)        | `pydantic`            |        |
| **03** | Zaawansowana walidacja: Gwarancja jako≈õci danych z LLM         | `pydantic-validators` |        |
| **04** | Serializacja i deserializacja z≈Ço≈ºonych obiekt√≥w JSON          | `pydantic`            |        |
| **05** | Self-correction loop: Automatyczna naprawa b≈Çƒôd√≥w formatowania | `pydantic`            |        |
| **06** | Integracja Pydantic z PydanticAI oraz Google SDK               | `pydantic-ai, gemini` |        |

**Oczekiwane Wyniki:**

- Wdro≈ºysz Pydantic jako centralny punkt prawdy o danych w swojej aplikacji
- Uzyskasz gwarancjƒô struktury (Structured Outputs) z dowolnego modelu LLM
- Zautomatyzujesz naprawƒô b≈Çƒôdnych odpowiedzi modeli poprzez pƒôtle walidacji

---

### **Modu≈Ç 4: LLM Science & Prompt Engineering**

| Lekcja | Temat G≈Ç√≥wny                                                  | Tech Stack           | Status |
| ------ | ------------------------------------------------------------- | -------------------- | ------ |
| **01** | Architektura transformera: Wagi, warstwy i mechanizm uwagi    | `transformers`       |        |
| **02** | Reasoning Models: Modele klasy DeepSeek-R1 oraz O1            | `deepseek, openai`   |        |
| **03** | Techniki zaawansowane: Chain-of-Thought i Few-shot            | `prompt-engineering` |        |
| **04** | System Routing i inteligentne kierowanie prompt√≥w             | `semantic-routing`   |        |
| **05** | ZarzƒÖdzanie oknem kontekstowym i problem "lost in the middle" | `context-management` |        |
| **06** | Fine-tuning vs RAG: Kiedy faktycznie trenowaƒá w≈Çasny model?   | `fine-tuning, rag`   |        |

**Oczekiwane Wyniki:**

- Zrozumiesz wewnƒôtrzne dzia≈Çanie najnowszych modeli klasy Reasoning
- Opanujesz techniki promptingu, kt√≥re wyciskajƒÖ 100% z du≈ºych modeli
- Samodzielnie ocenisz, czy dany problem wymaga RAG, czy modyfikacji wag modelu

---

## üîß FAZA 3: NATIVE SDKs & AGENT FRAMEWORKS

### **Modu≈Ç 5: Google Generative AI SDK ‚Äì Natywna Integracja**

| Lekcja | Temat G≈Ç√≥wny                                                    | Tech Stack            | Status |
| ------ | --------------------------------------------------------------- | --------------------- | ------ |
| **01** | Praca z rodzinƒÖ Gemini (Flash, Pro) przez natywne SDK           | `google-generativeai` |        |
| **02** | Autentykacja i limitowanie zapyta≈Ñ w profesjonalnym SDK         | `google-auth`         |        |
| **03** | Konfiguracja System Instructions dla modeli Google              | `gemini`              |        |
| **04** | Safety Settings i precyzyjne filtrowanie tre≈õci                 | `gemini-safety`       |        |
| **05** | Native Function Calling: Pozw√≥l Gemini wywo≈Çywaƒá Tw√≥j kod       | `function-calling`    |        |
| **06** | Projektowanie stabilnych narzƒôdzi (Tools) dla Gemini            | `gemini-tools`        |        |
| **07** | Context Caching: Drastyczne obni≈ºanie koszt√≥w (D≈Çugi Kontekst)  | `gemini-caching`      |        |
| **08** | ZarzƒÖdzanie cyklem ≈ºycia cache'u w ≈õrodowisku produkcyjnym      | `cache-management`    |        |
| **09** | Multimodalno≈õƒá: Analiza obraz√≥w i wideo w jednym nurcie         | `gemini-multimodal`   |        |
| **10** | Przetwarzanie dokument√≥w PDF przez natywne API                  | `gemini-pdf`          |        |
| **11** | Batch API: Przetwarzanie masowe danych poza czasem rzeczywistym | `gemini-batch`        |        |
| **12** | Optymalizacja koszt√≥w i monitoring proces√≥w wsadowych           | `batch-monitoring`    |        |

**Oczekiwane Wyniki:**

- Wykorzystasz pe≈ÇnƒÖ moc modeli Gemini (2M token√≥w) przez natywne SDK Google
- Wdro≈ºysz Function Calling, pozwalajƒÖc modelowi operowaƒá na Twojej logice biznesowej
- Drastycznie obni≈ºysz koszty infrastruktury dziƒôki mechanizmowi Context Caching

---

### **Modu≈Ç 6: PydanticAI ‚Äì Budowa Profesjonalnych Agent√≥w**

| Lekcja | Temat G≈Ç√≥wny                                                      | Tech Stack             | Status |
| ------ | ----------------------------------------------------------------- | ---------------------- | ------ |
| **01** | Architektura PydanticAI: Agenci oparci na typach danych           | `pydantic-ai`          |        |
| **02** | Konfiguracja i inicjalizacja ≈õrodowiska PydanticAI                | `pydantic-ai`          |        |
| **03** | Definiowanie narzƒôdzi agenta (@agent.tool) z walidacjƒÖ            | `pydantic-ai-tools`    |        |
| **04** | Integracja narzƒôdzi zewnƒôtrznych i walidacja typ√≥w                | `pydantic-ai`          |        |
| **05** | Dependency Injection: Bezpieczne przekazywanie baz danych i API   | `dependency-injection` |        |
| **06** | ZarzƒÖdzanie stanem i wstrzykiwanie zale≈ºno≈õci w agentach          | `state-management`     |        |
| **07** | Multi-agent systems: Strategie delegacji zada≈Ñ (Hand-off)         | `multi-agent`          |        |
| **08** | Koordynacja pracy zespo≈Çu agent√≥w i wymiana informacji            | `agent-coordination`   |        |
| **09** | ZarzƒÖdzanie logikƒÖ decyzyjnƒÖ i "my≈õleniem" agenta                 | `agent-reasoning`      |        |
| **10** | Dynamiczne instrukcje systemowe w PydanticAI                      | `dynamic-instructions` |        |
| **11** | Testowanie agent√≥w: Unit testy dla zachowa≈Ñ niedeterministycznych | `pytest, mocking`      |        |
| **12** | Ewaluacja i debugowanie agent√≥w na poziomie kodu                  | `debugging-agents`     |        |

**Oczekiwane Wyniki:**

- Zbudujesz zaawansowanych agent√≥w w najbardziej po≈ºƒÖdanym frameworku 2025 roku
- Wdro≈ºysz bezpieczne wstrzykiwanie zale≈ºno≈õci (DI) w logice agentycznej
- Stworzysz systemy wieloagentowe potrafiƒÖce p≈Çynnie przekazywaƒá zadania

---

## üîÑ FAZA 4: ORCHESTRATION & OBSERVABILITY

### **Modu≈Ç 7: Orkiestracja Workflows i State Management**

| Lekcja | Temat G≈Ç√≥wny                                                    | Tech Stack               | Status |
| ------ | --------------------------------------------------------------- | ------------------------ | ------ |
| **01** | Projektowanie przep≈Çyw√≥w jako Maszyny Stan√≥w (FSM)              | `state-machines`         |        |
| **02** | Definiowanie graf√≥w stan√≥w i regu≈Ç przej≈õƒá w AI Workflows       | `workflow-graphs`        |        |
| **03** | Human-in-the-loop: Punkty kontrolne w procesach AI              | `hitl-patterns`          |        |
| **04** | Interwencja ludzka: Edycja stan√≥w i akceptacja danych           | `human-feedback`         |        |
| **05** | ZarzƒÖdzanie d≈Çugotrwa≈ÇƒÖ pamiƒôciƒÖ sesji w PostgreSQL             | `postgresql, sqlalchemy` |        |
| **06** | Projektowanie schemat√≥w baz danych pod pamiƒôƒá agent√≥w           | `database-design`        |        |
| **07** | Architektura Router√≥w: Inteligentne kierowanie zada≈Ñ do modeli  | `semantic-router`        |        |
| **08** | Kierowanie zapytaniami na podstawie intencji (Semantic Routing) | `intent-classification`  |        |
| **09** | Obs≈Çuga stan√≥w przej≈õciowych i persystencja w systemach         | `state-persistence`      |        |
| **10** | Backup i odtwarzanie stan√≥w agenta w przypadku awarii           | `disaster-recovery`      |        |
| **11** | Optymalizacja przep≈Çyw√≥w pod kƒÖtem op√≥≈∫nie≈Ñ (Latency)           | `performance-tuning`     |        |
| **12** | Redukcja narzutu czasowego przy orkiestracji wielu modeli       | `optimization`           |        |

**Oczekiwane Wyniki:**

- Zaprojektujesz stabilne i przewidywalne workflows oparte na maszynach stan√≥w
- Zaimplementujesz mechanizmy kontrolne wymagajƒÖce akceptacji cz≈Çowieka
- Skutecznie zarzƒÖdzisz pamiƒôciƒÖ sesji i persystencjƒÖ danych w bazach SQL

---

### **Modu≈Ç 8: Observability z Langfuse**

| Lekcja | Temat G≈Ç√≥wny                                                    | Tech Stack               | Status |
| ------ | --------------------------------------------------------------- | ------------------------ | ------ |
| **01** | Tracing: ≈öledzenie ka≈ºdego kroku agenta w czasie rzeczywistym   | `langfuse`               |        |
| **02** | Integracja Langfuse z aplikacjami Python i PydanticAI           | `langfuse-sdk`           |        |
| **03** | Analiza koszt√≥w (Token usage) i wydajno≈õci finansowej modeli    | `cost-tracking`          |        |
| **04** | Wyliczanie kosztu na u≈ºytkownika i na operacjƒô                  | `cost-analytics`         |        |
| **05** | LLM-as-a-judge: Automatyczna ewaluacja jako≈õci odpowiedzi       | `llm-evaluation`         |        |
| **06** | Projektowanie w≈Çasnych sƒôdzi√≥w (Evaluators) do jako≈õci danych   | `custom-evaluators`      |        |
| **07** | Debugowanie produkcji: Szybka identyfikacja "z≈Çych" ≈õcie≈ºek     | `production-debugging`   |        |
| **08** | Analiza wizualna ≈õlad√≥w (Traces) i identyfikacja wƒÖskich garde≈Ç | `trace-analysis`         |        |
| **09** | Dataset Management: Budowanie bazy testowej (Gold Datasets)     | `dataset-management`     |        |
| **10** | Wykonywanie eksperyment√≥w i por√≥wnywanie wersji prompt√≥w        | `a-b-testing`            |        |
| **11** | Feedback Loop: Integracja ocen u≈ºytkownik√≥w z observability     | `user-feedback`          |        |
| **12** | Budowa systemu ciƒÖg≈Çego ulepszania na podstawie danych z log√≥w  | `continuous-improvement` |        |

**Oczekiwane Wyniki:**

- Uzyskasz pe≈ÇnƒÖ widoczno≈õƒá (Observability) nad ka≈ºdym zapytaniem Twoich agent√≥w
- Wdro≈ºysz proces automatycznej ewaluacji jako≈õci bez udzia≈Çu cz≈Çowieka
- Zbudujesz bazƒô Gold Datasets s≈Çu≈ºƒÖcƒÖ do profesjonalnych test√≥w regresji

---

## üóÑÔ∏è FAZA 5: VECTOR DATABASES & RAG

### **Modu≈Ç 9: Suwerenny RAG z Qdrant Vector DB**

| Lekcja | Temat G≈Ç√≥wny                                                      | Tech Stack              | Status |
| ------ | ----------------------------------------------------------------- | ----------------------- | ------ |
| **01** | Dlaczego Qdrant? Architektura wektorowa dla skali produkcyjnej    | `qdrant`                |        |
| **02** | Instalacja, konfiguracja i skalowanie Qdrant (Docker)             | `qdrant, docker`        |        |
| **03** | In≈ºynieria chunkingu i strategie inteligentnego podzia≈Çu tekstu   | `chunking-strategies`   |        |
| **04** | Embedding strategies: Dob√≥r modelu osadzania do jƒôzyka polskiego  | `sentence-transformers` |        |
| **05** | Hybrydowe wyszukiwanie: ≈ÅƒÖczenie wektor√≥w z pe≈Çnotekstowym BM25   | `hybrid-search`         |        |
| **06** | Konfiguracja Sparse Vectors w Qdrant dla precyzji s≈Ç√≥w kluczowych | `sparse-vectors`        |        |
| **07** | Reranking: Drastyczna poprawa trafno≈õci dziƒôki Cross-Encoders     | `cross-encoder`         |        |
| **08** | Implementacja warstwy Reranker w potoku pobierania danych         | `reranking-pipeline`    |        |
| **09** | Filtrowanie metadanych i zaawansowane kolekcje w Qdrant           | `metadata-filtering`    |        |
| **10** | Filtry dynamiczne i payload management w bazach wektorowych       | `payload-management`    |        |
| **11** | Projekt: Prywatna baza wiedzy dzia≈ÇajƒÖca w 100% lokalnie          | `local-rag`             |        |
| **12** | Bezpieczny RAG On-premise zapewniajƒÖcy suwerenno≈õƒá danych         | `on-premise-deployment` |        |

**Oczekiwane Wyniki:**

- Opanujesz bazƒô Qdrant ‚Äì rynkowy standard dla profesjonalnych rozwiƒÖza≈Ñ AI
- Zaimplementujesz hybrydowe wyszukiwanie o najwy≈ºszej precyzji rynkowej
- Zbudujesz profesjonalny RAG dzia≈ÇajƒÖcy w 100% lokalnie, bez wycieku danych

---

## üö¢ FAZA 6: DEPLOYMENT & PRODUCTION

### **Modu≈Ç 10: Deployment & MLOps (FastAPI + Docker)**

| Lekcja | Temat G≈Ç√≥wny                                                        | Tech Stack                 | Status |
| ------ | ------------------------------------------------------------------- | -------------------------- | ------ |
| **01** | Budowa asynchronicznego API w FastAPI dla system√≥w AI               | `fastapi`                  |        |
| **02** | Projektowanie schemat√≥w wej≈õcia/wyj≈õcia (Pydantic) dla API          | `fastapi, pydantic`        |        |
| **03** | Konteneryzacja: Optymalizacja obraz√≥w Docker (GPU vs CPU)           | `docker`                   |        |
| **04** | ZarzƒÖdzanie warstwami i multi-stage builds dla mikroserwis√≥w        | `docker-multistage`        |        |
| **05** | Docker Compose Tactical: Pe≈Çny stos (App + Qdrant + Monitoring)     | `docker-compose`           |        |
| **06** | Konfiguracja sieci i izolacja us≈Çug w Dockerze                      | `docker-networking`        |        |
| **07** | Skalowanie agent√≥w: Workers, Queues (Redis) i Load Balancing        | `redis, celery`            |        |
| **08** | Obs≈Çuga kolejek zada≈Ñ dla d≈Çugo trwajƒÖcych przemy≈õle≈Ñ agenta        | `task-queues`              |        |
| **09** | Bezpiecze≈Ñstwo API: Autoryzacja i Rate Limiting w AI                | `api-security`             |        |
| **10** | Zabezpieczanie przed atakami typu Prompt Injection na poziomie kodu | `prompt-injection-defense` |        |
| **11** | CI/CD dla AI: Automatyzacja test√≥w i wdro≈ºe≈Ñ (GitHub Actions)       | `github-actions`           |        |
| **12** | Automatyczne budowanie obraz√≥w i deployment do chmury               | `ci-cd-automation`         |        |

**Oczekiwane Wyniki:**

- Wystawisz swoje agenty jako skalowalne, asynchroniczne API produkcyjne
- Zoptymalizujesz kontenery Docker pod kƒÖtem specyficznych wymaga≈Ñ AI
- Wdro≈ºysz pe≈Çny cykl MLOps zapewniajƒÖcy bezpiecze≈Ñstwo i ciƒÖg≈Ço≈õƒá dzia≈Çania

---

## üîå FAZA 7: ADVANCED PROTOCOLS

### **Modu≈Ç 11: Model Context Protocol (MCP)**

| Lekcja | Temat G≈Ç√≥wny                                                    | Tech Stack          | Status |
| ------ | --------------------------------------------------------------- | ------------------- | ------ |
| **01** | MCP: Nowy standard ≈ÇƒÖczenia LLM z danymi (2025)                 | `mcp`               |        |
| **02** | Architektura serwer√≥w MCP: Host vs Client                       | `mcp-architecture`  |        |
| **03** | Protok√≥≈Ç komunikacji i standardy JSON-RPC                       | `json-rpc`          |        |
| **04** | Budowa w≈Çasnego serwera MCP w Pythonie od podstaw               | `mcp-python`        |        |
| **05** | ≈ÅƒÖczenie LLM z lokalnymi bazami danych i systemem plik√≥w        | `mcp-integrations`  |        |
| **06** | Projektowanie bezpiecznych most√≥w danych (Data Bridges)         | `data-bridges`      |        |
| **07** | Integracja MCP z systemami operacyjnymi i narzƒôdziami lokalnymi | `os-integration`    |        |
| **08** | U≈ºycie MCP w profesjonalnych ≈õrodowiskach IDE (Cursor, VS Code) | `ide-integration`   |        |
| **09** | Rozszerzanie mo≈ºliwo≈õci agent√≥w przez dynamiczne zasoby         | `dynamic-resources` |        |

**Oczekiwane Wyniki:**

- Opanujesz Model Context Protocol ‚Äì standard, kt√≥ry zmienia spos√≥b dostƒôpu do danych
- Zbudujesz autorskie serwery MCP obs≈ÇugujƒÖce Tw√≥j lokalny system plik√≥w i bazy
- Zintegrujesz swoje agenty z zewnƒôtrznymi narzƒôdziami w ustandaryzowany spos√≥b

---

## üèÜ FAZA 8: CAPSTONE PROJECT

### **Modu≈Ç 12: Projekt Ko≈Ñcowy: RODO_EXPERT_AI**

| Lekcja | Temat G≈Ç√≥wny                                                  | Tech Stack            | Status |
| ------ | ------------------------------------------------------------- | --------------------- | ------ |
| **01** | System Design: Projektowanie architektury ca≈Çego rozwiƒÖzania  | `system-design`       |        |
| **02** | Dob√≥r technologii i modelowanie przep≈Çyw√≥w biznesowych        | `technology-stack`    |        |
| **03** | Implementacja lokalnego RAG z u≈ºyciem Qdrant dla dokument√≥w   | `qdrant, rag`         |        |
| **04** | Budowa systemu agent√≥w specjalistycznych w PydanticAI         | `pydantic-ai`         |        |
| **05** | Implementacja zaawansowanej logiki weryfikacji w FastAPI      | `fastapi, validation` |        |
| **06** | Tworzenie interfejsu i warstwy komunikacji z u≈ºytkownikiem    | `ui-layer`            |        |
| **07** | Wdro≈ºenie pe≈Çnego monitoringu Langfuse w kontenerze Docker    | `langfuse, docker`    |        |
| **08** | Testowanie E2E systemu pod kƒÖtem halucynacji i bezpiecze≈Ñstwa | `e2e-testing`         |        |
| **09** | Przygotowanie dokumentacji in≈ºynierskiej projektu ko≈Ñcowego   | `documentation`       |        |
| **10** | Optymalizacja wydajno≈õci i koszt√≥w ko≈Ñcowego rozwiƒÖzania      | `optimization`        |        |
| **11** | Roadmapa kariery: Jak zostaƒá Architektem System√≥w AI          | `career-path`         |        |
| **12** | Finalna prezentacja projektu i podsumowanie bootcampu         | `presentation`        |        |

**Oczekiwane Wyniki:**

- Zrealizujesz system RODO_EXPERT_AI ≈ÇƒÖczƒÖcy wszystkie technologie kursu
- Zbudujesz portfolio in≈ºynierskie, kt√≥re otworzy Ci drzwi do topowych firm AI
- Zyskasz pewno≈õƒá w projektowaniu kompleksowych system√≥w agentowych od zera

---

## üìä Podsumowanie Bootcampu

- **Ca≈Çkowity czas nauki:** 2x / tydz. (90‚Äì120 min) x 5 mc = 63-84 godzin
- **Liczba modu≈Ç√≥w:** 12
- **Liczba lekcji:** 123

### **Stack Technologiczny:**

**Core Python:**

- `asyncio, typing, mypy`
- `pydantic, pydantic-ai`
- `fastapi`

**LLM & AI:**

- `google-generativeai (Gemini)`
- `transformers, sentence-transformers`
- `ollama, deepseek`

**Vector DB & RAG:**

- `qdrant`
- `cross-encoder`

**Observability & Testing:**

- `langfuse`
- `pytest`

**MLOps & Deployment:**

- `docker, docker-compose`
- `redis, celery`
- `github-actions`

**Data & State:**

- `postgresql, sqlalchemy`
- `state-machines`

**Protocols:**

- `mcp (Model Context Protocol)`

### **Po uko≈Ñczeniu bƒôdziesz potrafiƒá:**

‚úÖ Projektowaƒá i wdra≈ºaƒá zaawansowane systemy agentowe  
‚úÖ Budowaƒá skalowalne API dla aplikacji AI  
‚úÖ Implementowaƒá RAG z pe≈ÇnƒÖ kontrolƒÖ nad danymi  
‚úÖ Monitorowaƒá i optymalizowaƒá koszty produkcyjnych system√≥w  
‚úÖ Tworzyƒá bezpieczne, suwerenne rozwiƒÖzania AI  
‚úÖ Pracowaƒá jako Modern AI Engineer lub Architekt System√≥w AI

---

**Author:** TakzenAI: Krzysztof Pika
